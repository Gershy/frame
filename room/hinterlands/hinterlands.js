U.buildRoom({
  name: 'hinterlands',
  innerRooms: [ 'record' ],
  build: (foundation, record) => {
    
    // NOTE: Recs generated by Below need custom uids to avoid conflicts
    // inside `allRecs`. If Below has a "hut" Rec #00000152 - Above will
    // eventually sync a Rec with the same uid. That means when Below
    // will look for a member Rec with uid #00000152, and consider that
    // Rec to be a member of the incoming GroupRec - since it isn't
    // possible for the GroupRec to have a Member with RecType of "hut", 
    // an error will be thrown: unexpected RecType received!
    
    let doUpdate = (lands, msg) => {
      
      // Updates `lands` based on the contents of `msg`.
      
      let { version, content } = msg;
      if (version !== lands.version + 1) throw new Error(`Tried to move from version ${lands.version} -> ${version}`);
      
      let squad = U.WobSquad();
      let err = U.safe(() => {
        
        // Apply all operations
        let { addRec={}, remRec={}, updRec={} } = content;
        
        // "head" Recs existed before the current update. "tail" Recs are Recs
        // whose existence results from the update. A Rec coming into existence
        // may have member references to both HeadRecs and TailRecs
        let headRecs = lands.allRecs;
        let tailRecs = Map();
        let getHeadOrTailRec = uid => {
          if (headRecs.has(uid)) return headRecs.get(uid);
          if (tailRecs.has(uid)) return tailRecs.get(uid);
          return null;
        };
        
        // Add new Recs with dependency churning
        let waiting = addRec.toArr((v, uid) => v.gain({ uid }));
        while (waiting.length) {
          
          let attempt = waiting;
          waiting = [];
          
          for (let addVals of attempt) {
          
            let { type, value, members, uid } = addVals;
            
            // Convert all members from uid to Rec
            members = members.map(uid => getHeadOrTailRec(uid));
            
            // If a member couldn't be converted wait for a later churn
            if (members.find(m => !m)) { waiting.push(addVals); continue; }
            
            // All members are available - create the Rec!
            let newRec = lands.createRec(type, { uid, value, squad }, ...members);
            tailRecs.set(uid, newRec);
            
          }
          
          if (waiting.length === attempt.length) { // If churn achieved nothing we're stuck
            console.log('Head Recs:', headRecs.toArr((rec, uid) => `${uid}: ${U.nameOf(rec)}`).join('\n'));
            console.log(JSON.stringify(content, null, 2));
            throw new Error(`Unresolvable Rec dependencies`);
          }
          
        }
        
        // Update Recs directly
        updRec.forEach((newValue, uid) => {
          if (!lands.allRecs.has(uid)) throw new Error(`Tried to upd non-existent Rec @ ${uid}`);
          squad.wobble(lands.allRecs.get(uid), newValue);
        });
        
        // Remove Recs directly
        //let shutGroup = Set();
        remRec.forEach((val, uid) => {
          if (!lands.allRecs.has(uid)) throw new Error(`Tried to rem non-existent Rec @ ${uid}`);
          squad.shut(lands.allRecs.get(uid));
        });
        
      });
      
      squad.complete(err);
      
      if (err) { err.message = `Error in "update": ${err.message}`; throw err; }
      
      // We've successfully moved to our next version!
      lands.version = version;
      
    };
    
    let { Rec, Rel } = record;
    let { Hog, WobTmp, HorzScope } = U;
    
    let TERMS = [];
    
    let Lands = U.inspire({ name: 'Lands', methods: () => ({
      init: function({ heartbeatMs=10000, recTypes={} }) {
        
        if (recTypes.isEmpty()) throw new Error('No "recTypes" provided');
        
        this.pool = U.setup.CpuPool();
        
        this.heartbeatMs = heartbeatMs;
        this.recTypes = recTypes;
        this.uidCnt = 0;
        this.comWobs = {};
        
        this.servers = [];
        this.makeServers = [];
        
        this.allRecs = Map();                       // Map uid -> Rec
        this.hutsByCpuId = Map();                   // Map cpuId -> Hut
        
        /// {ABOVE=
        
        this.realRooms = [];                        // All supported Real Rooms
        
        /// =ABOVE} {BELOW=
        
        this.version = 0;                           // Track the version of Below
        this.heartbeatTimeout = null;               // Timeout reference
        this.resetHeartbeatTimeout();               // Initialize heartbeat Below
        
        /// =BELOW}
        
        this.arch = this.createRec('arch', { uid: '!arch' });
        
        this.addDefaultCommands();
        
      },
      addDefaultCommands: function() {
        
        this.comWob('error').hold(({ hut, msg, reply }) => { /* nothing */ });
        this.comWob('fizzle').hold(({ hut, msg, reply }) => { /* nothing */ });
        
        /// {ABOVE=
        
        this.comWob('getInit').hold(async ({ absConn, hut, msg, reply }) => {
          hut.version = 0;                                            // Reset version
          hut.sync = hut.sync.map(v => ({}));                         // Clear current delta
          hut.fols.forEach((fol, rec) => hut.toSync('addRec', rec));  // Gen full sync delta
          
          let update = hut.genSyncTell();
          let initBelow = await foundation.genInitBelow('text/html', absConn, hut.getTerm(), update);
          reply(initBelow);
        });
        this.comWob('modifyRec').hold(({ lands, hut, msg, reply }) => {
          if (!msg.has('uid')) return hut.tell({ command: 'error', type: 'uidMissing', orig: msg });
          if (!msg.has('val')) return hut.tell({ command: 'error', type: 'valMissing', orig: msg });
          let { uid, val } = msg;
          let rec = lands.allRecs.get(uid);
          if (!rec) return hut.tell({ command: 'error', type: 'uidNotFound', orig: msg });
          try { hut.modifyRec(rec, val); }
          catch(err) { hut.tell({ command: 'error', type: 'modifyError', message: err.message, orig: msg }); }
        });
        this.comWob('getFile').hold(({ hut, msg, reply }) => {
          reply(U.safe(
            () => foundation.getMountFile(msg.path),
            () => ({ command: 'error', type: 'fileNotFound', orig: msg })
          ));
        });
        this.comWob('thunThunk').hold(({ hut, msg, reply }) => { /* nothing */ });
        
        /// =ABOVE} {BELOW=
        
        this.comWob('update').hold(({ lands, hut, msg, reply }) => {
          
          let { version, content } = msg;
          if (version !== lands.version + 1) throw new Error(`Tried to move from version ${lands.version} -> ${version}`);
          
          let squad = U.WobSquad();
          let err = U.safe(() => {
            
            // Apply all operations
            let { addRec={}, remRec={}, updRec={} } = content;
            
            // "head" Recs existed before the current update. "tail" Recs are Recs
            // whose existence results from the update. A Rec coming into existence
            // may have member references to both HeadRecs and TailRecs
            let headRecs = lands.allRecs;
            let tailRecs = Map();
            let getHeadOrTailRec = uid => {
              if (headRecs.has(uid)) return headRecs.get(uid);
              if (tailRecs.has(uid)) return tailRecs.get(uid);
              return null;
            };
            
            // Add new Recs with dependency churning
            let waiting = addRec.toArr((v, uid) => v.gain({ uid }));
            while (waiting.length) {
              
              let attempt = waiting;
              waiting = [];
              
              for (let addVals of attempt) {
              
                let { type, value, members, uid } = addVals;
                
                // Convert all members from uid to Rec
                members = members.map(uid => getHeadOrTailRec(uid));
                
                // If a member couldn't be converted wait for a later churn
                if (members.find(m => !m)) { waiting.push(addVals); continue; }
                
                // All members are available - create the Rec!
                let newRec = lands.createRec(type, { uid, value, squad }, ...members);
                tailRecs.set(uid, newRec);
                
              }
              
              if (waiting.length === attempt.length) { // If churn achieved nothing we're stuck
                console.log('Head Recs:', headRecs.toArr((rec, uid) => `${uid}: ${U.nameOf(rec)}`).join('\n'));
                console.log(JSON.stringify(content, null, 2));
                throw new Error(`Unresolvable Rec dependencies`);
              }
              
            }
            
            // Update Recs directly
            updRec.forEach((newValue, uid) => {
              if (!lands.allRecs.has(uid)) throw new Error(`Tried to upd non-existent Rec @ ${uid}`);
              squad.wobble(lands.allRecs.get(uid), newValue);
            });
            
            // Remove Recs directly
            //let shutGroup = Set();
            remRec.forEach((val, uid) => {
              if (!lands.allRecs.has(uid)) throw new Error(`Tried to rem non-existent Rec @ ${uid}`);
              squad.shut(lands.allRecs.get(uid));
            });
            
          });
          
          squad.complete(err);
          
          if (err) { err.message = `Error in "update": ${err.message}`; throw err; }
          
          // We've successfully moved to our next version!
          lands.version = version;
          
        });
        
        /// =BELOW}
        
      },
      addReality: function(rootReal, reality) {
        
        // Note: Above, multiple Realities can exist for the same Real.
        // This is because Above includes all *possibile* Reals. The
        // Below, on the other hand, has a single determined Real - so
        // only 1 Reality can exist per Real Below. (VERY theoretically,
        // there could be separate Reals each with their own Reality,
        // Below. Like... something that runs in both Electron and the
        // browser at the same time??)
        
        if (rootReal) {
          if (rootReal.reality) throw new Error(`Real ${rootReal.nameChain.join('.')} already has Reality`);
          rootReal.reality = reality;
        }
        
        /// {ABOVE=
        
        // TODO: Should files be added to the entire foundation? Or only to a particular app?
        // Consider adding the file to the foundation, but also requiring something like:
        // `lands.addServableFile(`${reality.name}.css`);`
        let cssControls = reality.getCssControls();
        foundation.addMountDataAsFile(`${reality.name}.css`, 'text/css', cssControls.cmp);
        return Hog(() => {
          foundation.remMountFile(`${reality.name}.css`);
          if (rootReal) rootReal.reality = null;
        });
        
        /// =ABOVE} {BELOW=
        
        let { query } = foundation.parseUrl(window.location.toString());
        
        let styleElem = document.createElement('link');
        styleElem.setAttribute('rel', 'stylesheet');
        styleElem.setAttribute('type', 'text/css');
        styleElem.setAttribute('media', 'screen');
        styleElem.setAttribute('href', `/!FILE/${reality.name}.css${query.has('spoof') ? `?spoof=${query.spoof}` : ''}`);
        document.head.appendChild(styleElem);
        
        real.dom.id = `${reality.name}`;
        return Hog(() => {
          real.dom.id = '';
          if (rootReal) rootReal.reality = null;
        });
        
        /// =BELOW}
        
      },
      nextUid: function() { return (this.uidCnt++).toString(36).padHead(8, '0'); },
      genUniqueTerm: function() {
        // If we used `getTerm` we could get an infinite loop! Simply exclude
        // any Huts that don't yet have a term
        let terms = Set(this.getAllHuts().map(h => h.term || C.skip));
        
        for (let i = 0; i < 100; i++) { // TODO: This is no good - `100` is arbitrary!
          let ret = TERMS[Math.floor(Math.random() * TERMS.length)]; // TODO: Should use chance room
          if (!terms.has(ret)) return ret;
        }
        throw new Error('Too many huts! Not enough terms!! AHHHH!!!');
      },
      
      createRec: function(name, params={}, ...args) {
        // TODO: Don't use this for Hut and ArchHut??
        // They shouldn't be included in allRecs, and they should
        // have non-trivial ids. Hut still needs a `lands` param tho
        if (!this.recTypes.has(name)) throw new Error(`Invalid RecType name: "${name}"`)
        if (!params.has('uid')) params.uid = this.nextUid();
        params.lands = this;
        let rec = this.recTypes[name].create(params, ...args);
        this.allRecs.set(rec.uid, rec);
        rec.shutWob().hold(() => this.allRecs.rem(rec.uid));
        return rec;
      },
      comWob: function(command) {
        if (!this.comWobs.has(command)) this.comWobs[command] = U.Wob({});
        return this.comWobs[command];
      },
      hear: async function(absConn, hut, msg, reply=null) {
        if (msg === null) return; // TODO: Necessary? I think servers already prevent null messages
        
        let { command } = msg;
        
        // Note: We don't allow a new `comWob` to be created for
        // `command`; that could allow exploitation from Below.
        let comVal = { lands: this, absConn, hut, msg, reply };
        if (this.comWobs.has(command))  this.comWobs[command].wobble(comVal);
        if (hut.comWobs.has(command))   hut.comWobs[command].wobble(comVal);
      },
      tell: async function(msg) {
        /// {BELOW=
        this.resetHeartbeatTimeout(); // Already sending a sign of life; defer next heartbeat
        /// =BELOW}
        this.getAllHuts().forEach(hut => hut.tell(msg));
      },
      
      /// {ABOVE=
      setRealRooms: function(realRooms) { this.realRooms = realRooms; },
      /// =ABOVE}
      
      getRootReal: async function(realRoom=foundation.getDefaultRealRoom()) {
        let rootReal = await foundation.getRootReal();
        if (rootReal.reality) throw new Error('Reality already applied');
        let reality = realRoom.Reality('root');
        reality.addFlatLayouts(this.realLayout);
        rootReal.reality = reality;
        rootReal.layout = reality.rootLayout;
        return rootReal;
      },
      
      /// {BELOW=
      resetHeartbeatTimeout: function() {
        if (!this.heartbeatMs) return;
        
        // After exactly `this.heartbeatMs` millis Above will shut us down
        // Therefore we need to be quicker - wait less millis than `this.heartbeatMs`
        clearTimeout(this.heartbeatTimeout);
        this.heartbeatTimeout = setTimeout(() => this.tell({ command: 'thunThunk' }), Math.max(this.heartbeatMs * 0.85, this.heartbeatMs - 2000));
      },
      modifyRec: function(rec, newVal) {
        
        // Called from Below; affects `rec` Above!
        
        // TODO: Validation in {ABOVE= Lands.prototype.modifyRec =ABOVE}
        // and {BELOW= Hut.prototype.modifyRec =BELOW} disagree with
        // each other!
        // TODO: We can prevent the message from happening if `newVal`
        // is a redundant update!
        // TODO: The naming "newVal" (and the "val" property of the
        // "modifyRec" command) don't reflect that "newVal" is often a
        // delta - containing only the changed properties.
        
        let curVal = rec.value;
        if (curVal === newVal) return;
        
        // Only allow type-mixing between `null` and non-null values
        let nullUpd = curVal === null || newVal === null;
        
        if (!nullUpd && U.inspOf(curVal) !== U.inspOf(newVal))
          throw new Error(`Tried to update ${U.nameOf(curVal)} -> ${U.nameOf(newVal)}`);
        
        if (!nullUpd && U.isType(newVal, Object)) {
          let changedProp = false;
          for (let k in newVal) {
            if (!curVal.has(k)) throw new Error(`Tried to add non-existent property: "${k}"`);
            if (curVal[k] !== newVal[k]) changedProp = true;
          }
          if (!changedProp) return; // Tolerate this! No property changed. TODO: Recursively check inner properties?
        }
        
        this.tell({ command: 'modifyRec', uid: rec.uid, val: newVal });
      },
      /// =BELOW}
      
      getAllHuts: function() {
        return this.arch.relWob(rt.archHut, 0).toArr(archHut => archHut.members[1]);
      },
      
      // TODO: async functions shouldn't be named "open" and "shut"
      // TODO: should return a HorzScope I think??
      open: async function() {
        /// {ABOVE=
        TERMS = JSON.parse(await foundation.readFile('room/hinterlands/TERMS.json'));
        /// =ABOVE} {BELOW=
        TERMS = [ 'above' ]; // Below has only 1 FarHut, so only 1 name
        /// =BELOW}
        
        /// {ABOVE=
        
        // Temporarily create each supported Reality, and include its
        // compile-time assets
        for (let realRoom of this.realRooms) {
          
          let reality = realRoom.Reality('root'); // This instance exists temporarily
          reality.addFlatLayouts(this.realLayout);
          
          let staticAssets = reality.getCmpTimeFwkAssets();
          staticAssets.forEach(({ contentType, content }, key) => {
            foundation.addMountDataAsFile(key, contentType, content);
          });
          
        }
        
        /// =ABOVE}
        
        // Servers ultimately result in Cpus and CpuConns being wobbled
        this.servers = await Promise.allArr(this.makeServers.map(make => make(this.pool)));
        this.holdCpuWob = this.pool.cpuWob.hold(cpu => {
          
          // "farHut" and "ourHut" :P ("proclaim" = "inform all below")
          
          let cpuId = cpu.cpuId;
          let hut = this.createRec('hut', { cpuId, uid: `!hut:${cpuId}` });
          this.hutsByCpuId.set(cpuId, hut);
          
          cpu.connWob.hold(conn => { // Now `cpu` is also connected via `conn`
            
            hut.conns.add(conn);
            
            // If we could establish the structure that `conn.hear`
            // belongs to `conn` we could implicitly shut `conn.hear`
            // when `conn` shuts.
            let holdConn = conn.hear.hold(([ msg, reply=null ]) => {
              /// {ABOVE=
              hut.refreshExpiry();
              /// =ABOVE}
              this.hear(conn, hut, msg, reply);
            });
            
            conn.shutWob().hold(() => { holdConn.shut(); hut.conns.rem(conn); });
            
          });
          
          // Hut and Cpu only exist together
          hut.shutWob().hold(g => { if (!cpu.isShut()) cpu.shut(g); this.hutsByCpuId.rem(cpuId); });
          cpu.shutWob().hold(g => { if (!hut.isShut()) hut.shut(g) });
          
          this.createRec('archHut', { uid: `!archHut:${cpuId}` }, this.arch, hut);
          
        });
        
        /// {BELOW=
        
        // The only Hut which Below talks to is the Above Hut
        for (let server of this.servers) this.pool.makeCpuConn(server, conn => conn.cpuId = 'above');
        let aboveHut = this.getAllHuts().find(() => true)[0];
        await this.hear(null, aboveHut, U.initData); // Do the initial update
        
        /// =BELOW}
      },
      shut: async function() {
        // TODO: Also need to stop all servers! Servers should be `Wob`
        // and `Hog`!
        this.holdCpuWob.shut();
        await Promise.allArr(this.servers.map(server => server.shut()));
      }
    })});
    let Hut = U.inspire({ name: 'Hut', insps: { Rec }, methods: (insp, Insp) => ({
      
      init: function({ lands, cpuId, ...supArgs }) {
        
        if (!lands) throw new Error('Missing "lands"'); // TODO: Can this property be removed? It's aaalmost unnecessary
        if (!cpuId) throw new Error('Missing "cpuId"');
        
        insp.Rec.init.call(this, supArgs);
        this.lands = lands;
        this.cpuId = cpuId;
        this.term = null;
        this.comWobs = {};
        this.conns = Set();
        
        /// {ABOVE=
        // Keep track of which Records the Below for this Hut has followed
        this.version = 0;
        this.fols = Map();
        this.sync = { addRec: {}, updRec: {}, remRec: {} };
        
        // Keep track of whether the Below for this Hut is still communicating
        this.syncThrottlePrm = null; // Resolves when we've sent sync to Below
        this.expiryTimeout = null;
        this.refreshExpiry();
        /// =ABOVE}
        
      },
      getTerm: function() {
        if (!this.term) this.term = this.lands.genUniqueTerm();
        return this.term;
      },
      comWob: function(command) {
        if (!this.comWobs.has(command)) this.comWobs[command] = U.Wob({});
        return this.comWobs[command];
      },
      
      /// {ABOVE=
      refreshExpiry: function() {
        clearTimeout(this.expiryTimeout);
        this.expiryTimeout = setTimeout(() => this.shut(), this.lands.heartbeatMs);
      },
      
      toSync: function(type, rec) {
        
        if (!this.sync.has(type)) throw new Error(`Invalid type: ${type}`);
        let { addRec, updRec, remRec } = this.sync;
        
        // Can addRec and remRec occur together? NO  (conflicting messages!)
        // Can addRec and updRec occur together? NO  (redundant!)
        // Can remRec and updRec occur together? YES (e.g. animation upon deletion)
        
        if (type === 'addRec') {
          
          if (remRec.has(rec.uid))  delete remRec[rec.uid];
          else                      { delete updRec[rec.uid]; addRec[rec.uid] = rec; }
          
        } else if (type === 'remRec') {
          
          if (addRec.has(rec.uid))  delete addRec[rec.uid];
          else                      remRec[rec.uid] = rec;
          
        } else if (type === 'updRec') {
          
          if (addRec.has(rec.uid))  return; // No "updRec" necessary: already adding!
          else                      updRec[rec.uid] = rec;
          
        }
        
        this.requestSyncBelow();
        
      },
      requestSyncBelow: function() {
        
        // Schedules Below to be synced if not already scheduled
        
        let err = new Error('');
        
        this.syncThrottlePrm = (async () => {
          
          try {
            
            // await this.genSyncThrottlePrm();
            await new Promise(r => foundation.queueTask(r)); // TODO: This could be swapped out (to a timeout, or whatever!)
            
            this.syncThrottlePrm = null;
            
            // Hut may have been shut between scheduling and executing sync
            if (this.isShut()) return;
            
            let updateTell = this.genSyncTell();
            if (updateTell) this.tell(updateTell);
            
          } catch(err0) {
            throw err0;
            //err.message = `Error doing sync: ${err0.message}`;
            //throw err;
          }
          
        })();
        
      },
      genSyncTell: function() {
        
        // Generates sync data to bring the Below up to date. Has the side-effect
        // of clearing this Hut's memory of the current delta.
        
        let addRec = this.sync.addRec.map(r => ({ type: r.type.name, value: r.value, members: r.members.map(m => m.uid) }));
        let updRec = this.sync.updRec.map(r => r.value);
        let remRec = this.sync.remRec.map(r => 1);
        
        let content = {};
        if (!addRec.isEmpty()) content.addRec = addRec;
        if (!updRec.isEmpty()) content.updRec = updRec;
        if (!remRec.isEmpty()) content.remRec = remRec;
        if (content.isEmpty()) return null;
        
        this.sync = this.sync.map(v => ({}));
        this.version++;
        return { command: 'update', version: this.version, content };
        
      },
      
      getRecFollowStrength: function(rec) { return (this.fols.get(rec) || { strength: 0 }).strength; },
      setRecFollowStrength: function(rec, strength) {
        
        if (strength < 0) throw new Error(`Invalid strength ${strength} for ${rec.type.name}`);
        
        let fol = this.fols.get(rec) || null;     // The current Follow
        let strength0 = fol ? fol.strength : 0;   // The current FollowStrength
        if (strength === strength0) throw new Error(`Strength is already ${strength}`);
        
        // Our FollowStrength of `rec` is changing! There are 3 possibilities:
        // 1 - Strength moving from =0 to >0 : ADD REC!
        // 2 - Strength moving from >0 to >0 : DO NOTHING!
        // 3 - Strength moving from >0 to =0 : REM REC!
        
        if (!strength0) {                   // ADD
          
          // This HorzScope depends on `rec`. That means if `rec` shuts for
          // any reason, we will stop following it! We can also explicitly
          // cease following `rec` by calling `ap.shut()`
          HorzScope(U.WobVal(rec), (dep, rec, ap) => {
            
            // Track the follow. Note that this is NOT cleaned up with
            // `dep` - e.g. if `rec` shuts, this entry in `this.fols`
            // still persists. Instead use `setRecFollowStrength` to
            // decrement follow strength to 0!
            fol = { strength, ap, modifyAllow: Map(), modifyBlock: Map() }; // A single "any" and every "all" must pass
            this.fols.set(rec, fol);
            
            // Send a sync
            this.toSync('addRec', rec);
            dep(Hog(() => this.toSync('remRec', rec)));
            
            // Send upd syncs when `rec` wobbles (note `false` indicates non-hastiness)
            dep(rec.hold(val => this.toSync('updRec', rec), false));
            
          });
          return fol;
          
        } else if (strength0 && strength) { // UPD
          
          fol.strength = strength;
          
        } else {                            // REM
          
          // Close the HorzScope
          fol.ap.shut();
          this.fols.delete(rec);
          fol = null;
          
        }
        
        return fol;
        
      },
      followRec: function(rec, modify={}) {
        // TODO: Automatically follow `rec.members`?
        let fol = this.setRecFollowStrength(rec, this.getRecFollowStrength(rec) + 1);
        
        // Note that `fol.modifyAllow` and `fol.modifyBlock` map functions
        // to the hold strength of that specific function
        let { modifyAllow: anyF, modifyBlock: allF } = modify;
        if (anyF && !U.isType(anyF, Function)) throw new Error('Invalid "modifyAllow" value');
        if (allF && !U.isType(allF, Function)) throw new Error('Invalid "modifyBlock" value');
        if (anyF) fol.modifyAllow.set(anyF, (fol.modifyAllow.get(anyF) || 0) + 1);
        if (allF) fol.modifyBlock.set(allF, (fol.modifyBlock.get(allF) || 0) + 1);
        
        return Hog(() => {
          let fol = this.setRecFollowStrength(rec, this.getRecFollowStrength(rec) - 1);
          if (fol) {
            if (anyF) { let v = fol.modifyAllow.get(anyF); fol.modifyAllow[(v > 1) ? 'set' : 'rem'](anyF, v - 1); }
            if (allF) { let v = fol.modifyBlock.get(allF); fol.modifyBlock[(v > 1) ? 'set' : 'rem'](allF, v - 1); }
          }
        });
      },
      modifyRec: function(rec, newVal) {
        
        // A command from Below has wound us up here. Make sure that the
        // Below has permission to modify this `rec` as it desires, and
        // if so do the modification.
        
        if (rec.value !== null && newVal.value !== null)
          if (U.inspOf(rec.value) !== U.inspOf(newVal))
            throw new Error(`Can't modify - tried to modify ${U.nameOf(rec.value)} -> ${U.nameOf(newVal)}`);
        
        let fol = this.fols.get(rec);
        if (!fol) throw new Error(`Modification denied`);
        
        // Allow if any "modifyAllow" passes and no "modifyBlock" fails
        let anyAllow = false;
        for (let f of fol.modifyAllow.keys()) if (f(newVal)) { anyAllow = true; break; }
        if (!anyAllow) throw new Error(`Can't modify since no "any" passed`);
        
        let allPass = true;
        for (let f of fol.modifyBlock.keys()) if (f(newVal)) { allPass = false; break; }
        if (!allPass) throw new Error(`Can't modify since an "all" denied`);
        
        if (U.isType(newVal, Object)) rec.wobble({ ...(rec.value || {}), ...newVal });
        else                          rec.wobble(newVal);
      },
      
      shut0: function() {
        insp.Rec.shut0.call(this);
        clearTimeout(this.expiryTimeout); this.expiryTimeout = null;
      },
      /// =ABOVE}
      
      tell: function(msg, conn=null) {
        if (conn) {
          if (!this.conns.has(conn)) throw new Error(`Provided Conn doesn't connect this Hut`);
        } else {
          let bestCost = U.int32;
          for (let conn0 of this.conns) {
            if (conn0.serverWob.cost < bestCost) { conn = conn0; bestCost = conn0.serverWob.cost; }
          }
        }
        
        if (!conn) throw new Error(`Hut ${this.cpuId} has no Conns`);
        conn.tell(msg);
      }
    })});
    
    let { rt, add } = record.recTyper();
    add('arch',     Rec);
    add('hut',      Hut);
    add('archHut',  Rec, '1M', rt.arch, rt.hut);
    
    return { Lands, Hut, rt };
    
  }
});
