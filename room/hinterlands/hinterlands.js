U.buildRoom({
  name: 'hinterlands',
  innerRooms: [ 'record' ],
  build: (foundation, record) => {
    
    // NOTE: Recs generated by Below need custom uids to avoid conflicts
    // inside `allRecs`. If Below has a "hut" Rec #00000152 - Above will
    // eventually sync a Rec with the same uid. That means when Below
    // will look for a member Rec with uid #00000152, and consider that
    // Rec to be a member of the incoming GroupRec - since it isn't
    // possible for the GroupRec to have a Member with RecType of "hut", 
    // an error will be thrown: unexpected RecType received!
    
    // NOTE: Recs are created in 3 different manners:
    // 1 - Arch: May be referenced by other Huts; never dries. Created
    // without `Lands.prototype.createRec`, but still tracked within
    // `lands.allRecs`
    // 2 - ArchHut, Hut: May not be referenced by other Huts. Only dry
    // when the corresponding Cpu is rejected (for bad behaviour, etc),
    // or when the corresponding Cpu shuts. Are created without the use
    // of `Lands.prototype.createRec`; aren't tracked in `lands.allRecs`
    // 3 - All other Recs: May be referenced, and may dry up for any
    // reason! So we use `Lands.prototype.createRec`.
    
    let { RecTypes, RecType, Rec } = record;
    let { Drop, Nozz, Funnel, TubVal, TubSet, TubDry, Scope, defDrier } = U.water;
    
    let hutTerms = [];
    let syncOurHut = (ourHut, msg) => {
      
      let { version, content } = msg;
      if (version <= ourHut.syncVersion) throw new Error('Got duplicate sync');
      
      ourHut.earlySyncs.set(version, content);
      
      let nextVersion = ourHut.syncVersion + 1;
      while (ourHut.earlySyncs.has(nextVersion)) {
        
        // Apply all operations
        let { addRec={}, remRec={}, updRec={} } = content;
        
        // HeadRecs exist before update, TailRecs created by update;
        // TailRecs may have both HeadRecs and TailRecs as MemberRecs
        let headRecs = ourHut.allRecs;
        let tailRecs = Map();
        let getHeadOrTailRec = uid => headRecs.get(uid) || tailRecs.get(uid) || null;
        
        // Add new Recs with churning
        let waiting = addRec.toArr((v, uid) => ({ ...v, uid }));
        while (waiting.length) {
          
          let attempt = waiting;
          waiting = [];
          
          for (let addVals of attempt) {
          
            let { type, val, mems, uid } = addVals;
            
            // Convert all members from uid to Rec
            let members = null;
            if (U.isType(mems, Array)) {
              members = [];
              for (let uid of mems) {
                let memberRec = getHeadOrTailRec(uid);
                if (!memberRec) { members = null; break; }
                members.push(memberRec);
              }
            } else if (U.isType(mems, Object)) {
              members = {};
              for (let term in mems) {
                let memberRec = getHeadOrTailRec(mems[term]);
                if (!memberRec) { members = null; break; }
                members[term] = memberRec;
              }
            } else {
              throw new Error(`Unexpected mems: ${U.nameOf(mems)}`);
            }
            
            if (!members) { waiting.push(addVals); continue; }
            
            // All members are available - create the Rec!
            let newRec = ourHut.followRec(Rec(ourHut.getType(type), uid, members, val));
            tailRecs.set(uid, newRec);
            
          }
          
          if (waiting.length === attempt.length) { // If churn achieved nothing we're stuck
            console.log('Head Recs:\n', headRecs.toArr((rec, uid) => `- ${uid}: ${U.nameOf(rec)} (${rec.type.name})`).join('\n'));
            console.log('Tail Recs (created NOW):\n', tailRecs.toArr((rec, uid) => `- ${uid}: ${U.nameOf(rec)} (${rec.type.name})`).join('\n'));
            console.log(JSON.stringify(content, null, 2));
            throw Error(`Unresolvable Rec dependencies`);
          }
          
        }
        
        // Update Recs directly
        updRec.forEach((newValue, uid) => {
          if (!ourHut.allRecs.has(uid)) throw Error(`Tried to upd non-existent Rec @ ${uid}`);
          ourHut.allRecs.get(uid).setVal(newValue);
        });
        
        // Remove Recs directly
        remRec.forEach((val, uid) => {
          if (!ourHut.allRecs.has(uid)) throw Error(`Tried to rem non-existent Rec @ ${uid}`);
          ourHut.allRecs.get(uid).dry();
        });
          
        // We've successfully moved to our next version!
        ourHut.syncVersion = version;
        
        ourHut.earlySyncs.rem(nextVersion);
        nextVersion++;
      }
      
      if (ourHut.earlySyncs.size > 30) {
        console.log('QUEUE', ourHut.earlySyncs.toArr(content => U.nameOf(content)));
        throw new Error('Too many pending syncs');
      }
      
    };
    
    let Lands = U.inspire({ name: 'Lands', insps: { RecTypes }, methods: (insp, Insp) => ({
      init: function({ heartbeatMs=10000 }) {
        
        if (heartbeatMs < 3000) throw Error('Heartbeat too slow');
        
        insp.RecTypes.init.call(this);
        
        this.cpuPool = U.setup.CpuPool();
        this.heartbeatMs = heartbeatMs;
        this.uidCnt = 0;
        this.comNozzes = {};
        
        this.servers = [];
        this.makeServers = [];
        
        this.allRecs = Map();             // Map uid -> Rec
        this.earlySyncs = Map();
        
        /// {ABOVE=
        
        this.realRooms = [];              // All supported Real Rooms
        
        /// =ABOVE} {BELOW=
        
        this.compensatedHeartbeatMs = Math.max(this.heartbeatMs * 0.85 - 1000, this.heartbeatMs - 2000);
        this.syncVersion = 0;             // Track the version of Below
        this.heartbeatTimeout = null;     // Timeout reference
        this.resetHeartbeatTimeout();     // Initialize heartbeat Below
        
        /// =BELOW}
        
        // Note that Arch and ArchHut don't use `this.createRec`
        this.arch = Rec(this.getType('lands.arch'), '!arch');
        this.allRecs.set('!arch', this.arch);
        
        this.addDefaultCommands();
        
      },
      addDefaultCommands: function() {
        
        this.comNozz('error').route(({ hut, msg, reply }) => { /* nothing */ });
        this.comNozz('fizzle').route(({ hut, msg, reply }) => { /* nothing */ });
        
        /// {ABOVE=
        
        this.comNozz('modifyRec').route(({ hut, msg, reply }) => {
          if (!msg.has('uid')) return hut.tell({ command: 'error', type: 'uidMissing', orig: msg });
          if (!msg.has('val')) return hut.tell({ command: 'error', type: 'valMissing', orig: msg });
          let { uid, val } = msg;
          let rec = this.allRecs.get(uid);
          if (!rec) return hut.tell({ command: 'error', type: 'uidNotFound', orig: msg });
          try { hut.modifyRec(rec, val); }
          catch(err) { hut.tell({ command: 'error', type: 'modifyError', message: err.message, orig: msg }); }
        });
        this.comNozz('thunThunk').route(({ hut, msg, reply }) => { /* nothing */ });
        
        /// =ABOVE} {BELOW=
        
        this.comNozz('update').route(({ msg }) => syncOurHut(this, msg));
        
        /// =BELOW}
        
        this.comNozz('multi').route(({ absConn, hut, msg, reply }) => {
          
          let { list } = msg;
          if (!U.isType(list, Array)) return hut.tell({ command: 'error', type: 'invalidMultiList', orig: msg });
          
          // TODO: Would be cool if enough info were present to form a
          // multipart response when several files are requested...
          // That will take collaboration between hinterlands and
          // foundationNodejs' "makeHttpServer"
          for (let item of list) this.hear(absConn, hut, item, reply);
          
        });
        
      },
      genUniqueTerm: function() {
        // If we used `getTerm` we could get an infinite loop! Simply exclude
        // any Huts that don't yet have a term
        let terms = Set(this.getAllHuts().map(h => h.term || C.skip));
        
        for (let i = 0; i < 100; i++) { // TODO: This is no good - `100` is arbitrary!
          let ret = hutTerms[Math.floor(Math.random() * hutTerms.length)]; // TODO: Should use chance room
          if (!terms.has(ret)) return ret;
        }
        throw Error('Too many huts! Not enough terms!! AHHHH!!!');
      },
      
      getNextRecUid: function() { return U.base62(this.uidCnt++).padHead(8, '0'); },
      createRec: function(...args) { return this.followRec(insp.RecTypes.createRec.call(this, ...args)); },
      followRec: function(rec) {
        this.allRecs.set(rec.uid, rec);
        rec.drierNozz().route(() => this.allRecs.rem(rec.uid));
        return rec;
      },
      comNozz: function(command) {
        if (!this.comNozzes.has(command)) {
          this.comNozzes[command] = Nozz();
          this.comNozzes[command].desc = `Lands ComNozz for "${command}"`;
        }
        return this.comNozzes[command];
      },
      hear: async function(absConn, hut, msg, reply=null) {
        
        /// {ABOVE=
        hut.refreshExpiry(); // We heard from this Hut so renew!
        /// =ABOVE}
        
        let command = msg.command;
        
        // Note: We don't allow a new `comNozz` to be created for
        // `command`; that could allow exploitation from Below.
        let comVal = { lands: this, absConn, hut, msg, reply };
        
        let landsCom = this.comNozzes.has(command) ? this.comNozzes[command] : null;
        let hutCom = hut.comNozzes.has(command) ? hut.comNozzes[command] : null;
        
        // TODO: `reply` should always be available, default: `hut.tell`
        if (!landsCom && !hutCom) return (reply || hut.tell)({ command: 'error', type: 'invalidCommand', orig: msg });
        
        if (landsCom) landsCom.drip(comVal);
        if (hutCom) hutCom.drip(comVal);
        
      },
      tell: async function(msg) {
        /// {BELOW=
        this.resetHeartbeatTimeout(); // Already sending a sign of life; defer next heartbeat
        /// =BELOW}
        this.getAllHuts().forEach(hut => hut.tell(msg));
      },
      getRootReal: async function(realRoom=foundation.getDefaultRealRoom()) {
        let rootReal = await foundation.getRootReal();
        if (rootReal.reality) throw Error('Reality already applied');
        let reality = realRoom.Reality('root');
        reality.addFlatLayouts(this.realLayout);
        rootReal.reality = reality;
        rootReal.layout = reality.rootLayout;
        return rootReal;
      },
      
      /// {ABOVE=
      setRealRooms: function(realRooms) { this.realRooms = realRooms; },
      /// =ABOVE} {BELOW=
      resetHeartbeatTimeout: function() {
        // After exactly `this.heartbeatMs` millis Above will shut us down
        // Therefore we need to be quicker - wait less millis than `this.heartbeatMs`
        clearTimeout(this.heartbeatTimeout);
        this.heartbeatTimeout = setTimeout(() => this.tell({ command: 'thunThunk' }), this.compensatedHeartbeatMs);
      },
      modifyRec: function(rec, newVal) {
        
        // Called from Below; affects `rec` Above!
        
        // TODO: Validation in {ABOVE= Lands.prototype.modifyRec =ABOVE}
        // and {BELOW= Hut.prototype.modifyRec =BELOW} disagree with
        // each other!
        // TODO: We can prevent the message from happening if `newVal`
        // is a redundant update!
        // TODO: The naming "newVal" (and the "val" property of the
        // "modifyRec" command) don't reflect that "newVal" is often a
        // delta - containing only the changed properties.
        
        let curVal = rec.val;
        if (curVal === newVal) return;
        
        // Only allow type-mixing between `null` and non-null values
        let nullUpd = curVal === null || newVal === null;
        
        if (!nullUpd && U.inspOf(curVal) !== U.inspOf(newVal))
          throw Error(`Tried to update ${U.nameOf(curVal)} -> ${U.nameOf(newVal)}`);
        
        if (!nullUpd && U.isType(newVal, Object)) {
          let changedProp = false;
          for (let k in newVal) {
            if (!curVal.has(k)) throw Error(`Tried to add non-existent property: "${k}"`);
            if (curVal[k] !== newVal[k]) changedProp = true;
          }
          if (!changedProp) return; // Tolerate this! No property changed. TODO: Recursively check inner properties?
        }
        
        this.tell({ command: 'modifyRec', uid: rec.uid, val: newVal });
      },
      /// =BELOW}
      
      getAllHuts: function() {
        return this.arch.relRecs('lands.archHut').toArr(archHut => archHut.members['lands.hut']);
      },
      
      // TODO: async functions shouldn't be named "open" and "shut"
      // TODO: should return a HorzScope I think??
      open: async function() {
        /// {ABOVE=
        let termsSaved = foundation.getSaved([ 'room', 'hinterlands', 'terms.json' ]);
        hutTerms = JSON.parse(await termsSaved.getContent());
        /// =ABOVE} {BELOW=
        hutTerms = [ 'above' ]; // Below has only 1 FarHut, so only 1 name
        /// =BELOW}
        
        /// {ABOVE=
        // Setup each supported Reality (using temporary instances)
        for (let realRoom of this.realRooms) {
          let reality = realRoom.Reality('root');
          reality.addFlatLayouts(this.realLayout || {});
          await reality.prepareAboveLands(this);
        }
        /// =ABOVE}
        
        // Servers ultimately result in Cpus and CpuConns being wobbled
        this.servers = await Promise.allArr(this.makeServers.map(make => make(this.cpuPool)));
        this.cpuScope = Scope(this.cpuPool.cpuNozz, (cpu, dep) => {
          
          let cpuId = cpu.cpuId;
          
          // Create a Hut; it will be throttled until it gives us a Tell
          let hut = Hut(this, cpu, this.getType('lands.hut'), `!hut@${cpuId}`);
          
          // Now that the Hut is safely throttled connect it to ArchHut
          let archHut = Rec(this.getType('lands.archHut'), `!archHut@${cpuId}`, [ this.arch, hut ]);
          
          // Listen to each Conn of the Cpu
          dep.scp(cpu.connNozz, (conn, dep) => {
            
            // Listen to Commands coming from the Conn
            dep(conn.hear.route(args => this.hear(conn, hut, ...args))); // `args` is [ msg, reply ]
            
          });
          
        });
        
        /// {BELOW=
        // The only Hut which Below talks to is the Above Hut
        for (let server of this.servers) this.cpuPool.makeCpuConn(server, conn => conn.cpuId = 'above');
        let aboveHut = this.getAllHuts().find(() => true)[0];
        if (U.initData) await this.hear(null, aboveHut, U.initData); // Do the initial update
        /// =BELOW}
      },
      onceDry: function() {
        this.cpuScope.dry();
        for (let server of this.servers) server.dry();
      }
    })});
    let Hut = U.inspire({ name: 'Hut', insps: { Rec }, methods: (insp, Insp) => ({
      
      init: function(lands, cpu, type, uid, members, val) {
        
        if (!lands) throw Error('Missing "lands"'); // TODO: Can this property be removed? It's aaalmost unnecessary
        if (!cpu) throw Error('Missing "cpu"');
        
        insp.Rec.init.call(this, type, uid, members, val);
        this.lands = lands;   // TODO: Only needed for "getTerm" and "refreshExpiry"
        this.cpu = cpu;       // TODO: Only needed in "tell" (this.cpu.connNozz.set)
        this.term = null;
        this.comNozzes = {};
        
        /// {ABOVE=
        // Keep track of which Records the Below for this Hut has followed
        
        this.version = 0;
        this.fols = Map();
        this.sync = { addRec: {}, updRec: {}, remRec: {} };
        
        // Keep track of whether the Below for this Hut is still communicating
        this.syncThrottlePrm = null; // Resolves when we've sent sync to Below
        this.expiryTimeout = null;
        this.refreshExpiry();
        /// =ABOVE}
        
      },
      getTerm: function() {
        if (!this.term) this.term = this.lands.genUniqueTerm();
        return this.term;
      },
      comNozz: function(command) {
        if (!this.comNozzes.has(command)) {
          this.comNozzes[command] = Nozz();
          this.comNozzes[command].desc = `Hut ComNozz for "${command}"`
        }
        return this.comNozzes[command];
      },
      
      /// {ABOVE=
      refreshExpiry: function() {
        clearTimeout(this.expiryTimeout);
        this.expiryTimeout = setTimeout(() => this.dry(), this.lands.heartbeatMs);
      },
      
      toSync: function(type, rec) {
        
        if (!this.sync.has(type)) throw Error(`Invalid type: ${type}`);
        let { addRec, updRec, remRec } = this.sync;
        
        // addRec, remRec: cancel out! No information on Rec is sent
        // remRec, addRec: cancel out! (Rec is present Below, and stays)
        
        // Can addRec and remRec occur together? NO  (conflicting messages!)
        // Can addRec and updRec occur together? NO  (redundant!)
        // Can remRec and updRec occur together? YES (e.g. animation upon deletion)
        
        if (type === 'addRec') {
          if (remRec.has(rec.uid))  delete remRec[rec.uid];
          else                      addRec[rec.uid] = (delete updRec[rec.uid], rec);
        } else if (type === 'remRec') {
          if (addRec.has(rec.uid))  delete addRec[rec.uid];
          else                      remRec[rec.uid] = rec;
        } else if (type === 'updRec') {
          if (addRec.has(rec.uid))  return; // No "updRec" necessary: already adding!
          else                      updRec[rec.uid] = rec;
        }
        
        this.requestSyncBelow();
        
      },
      throttleSyncBelow: function() { return Promise(r => foundation.queueTask(r)); },
      requestSyncBelow: function() {
        
        // Schedules Below to be synced if not already scheduled
        
        if (this.syncThrottlePrm) return; // A request to sync already exists
        
        let ctxErr = Error('');
        
        this.syncThrottlePrm = (async () => {
          
          let throttlePrm = this.throttleSyncBelow();
          await throttlePrm;
          this.syncThrottlePrm = null;
          
          // Hut may have dried between scheduling and executing sync
          if (this.isDry()) return;
          
          let updateTell = this.genSyncTell(ctxErr);
          if (updateTell) this.tell(updateTell);
          
        })();
        
      },
      
      resetSyncState: function() {
        this.version = 0;                                           // Reset version
        this.sync = this.sync.map(v => ({}));                       // Clear current delta
        this.fols.forEach((f, rec) => this.toSync('addRec', rec));  // Sync all addRecs
      },
      genSyncTell: function(ctxErr=Error('')) {
        
        // Generates data to sync the BelowHut, and flags the BelowHut
        // as fully up to date
        
        let addRec = this.sync.addRec.map(r => ({ type: r.type.name, val: r.val, mems: r.members.map(m => m.uid) }));
        let updRec = this.sync.updRec.map(r => r.val);
        let remRec = this.sync.remRec.map(r => 1);
        
        let content = {};
        if (!addRec.isEmpty()) content.addRec = addRec;
        if (!updRec.isEmpty()) content.updRec = updRec;
        if (!remRec.isEmpty()) content.remRec = remRec;
        if (content.isEmpty()) return null;
        
        this.sync = this.sync.map(v => ({}));
        this.version++;
        return { command: 'update', version: this.version, content };
        
      },
      
      getRecFollowStrength: function(rec) { return (this.fols.get(rec) || { strength: 0 }).strength; },
      setRecFollowStrength: function(rec, strength) {
        
        if (strength < 0) throw Error(`Invalid strength ${strength} for ${rec.type.name}`);
        
        let fol = this.fols.get(rec) || null;     // The current Follow
        let strength0 = fol ? fol.strength : 0;   // The current FollowStrength
        if (strength === strength0) throw Error(`Strength is already ${strength}`);
        if (strength > strength0 && rec.isDry()) throw Error(`Tried to increase follow on dry ${rec.type.name}@${rec.uid}`);
        
        // Our FollowStrength of `rec` is changing! There are 3 possibilities:
        // 1 - Strength moving from =0 to >0 : ADD REC!
        // 2 - Strength moving from >0 to >0 : DO NOTHING!
        // 3 - Strength moving from >0 to =0 : REM REC!
        
        if (!strength0) {                   // ADD
          
          // Follow ends when Rec is unfollowed, or Rec dries
          
          this.toSync('addRec', rec);
          let updRecRoute = rec.route(() => this.toSync('updRec', rec));
          
          let recDryRoute = rec.drierNozz().route(() => unfollow.fn());
          let unfollow = { fn: () => {
            unfollow.fn = () => {};
            updRecRoute.dry();          // Stop listening to updates
            this.toSync('remRec', rec); // Sync that this Rec has been removed
            this.fols.rem(rec);         // 
          }};
          
          fol = { strength, unfollow, modifyAllow: Map(), modifyBlock: Map() };
          this.fols.set(rec, fol);
          
        } else if (strength0 && strength) { // UPD
          
          fol.strength = strength;
          
        } else {                            // REM
          
          fol.unfollow.fn();
          fol = null;
          
        }
        
        return fol;
        
      },
      followRec: function(rec, modify={}) {
        // TODO: Automatically follow `rec.members`?
        let fol = this.setRecFollowStrength(rec, this.getRecFollowStrength(rec) + 1);
        
        // Note that `fol.modifyAllow` and `fol.modifyBlock` map functions
        // to the hold strength of that specific function
        let { modifyAllow: anyF, modifyBlock: allF } = modify;
        if (anyF && !U.isType(anyF, Function)) throw Error('Invalid "modifyAllow" value');
        if (allF && !U.isType(allF, Function)) throw Error('Invalid "modifyBlock" value');
        if (anyF) fol.modifyAllow.set(anyF, (fol.modifyAllow.get(anyF) || 0) + 1);
        if (allF) fol.modifyBlock.set(allF, (fol.modifyBlock.get(allF) || 0) + 1);
        
        return Drop(null, () => {
          let fol = this.setRecFollowStrength(rec, this.getRecFollowStrength(rec) - 1);
          if (fol) {
            if (anyF) { let v = fol.modifyAllow.get(anyF); fol.modifyAllow[(v > 1) ? 'set' : 'rem'](anyF, v - 1); }
            if (allF) { let v = fol.modifyBlock.get(allF); fol.modifyBlock[(v > 1) ? 'set' : 'rem'](allF, v - 1); }
          }
        });
      },
      follow: function(rec) {
        // Note: may pass Recs with "!"-prefixed uids - they're ignored
        let drops = [ rec, ...rec.members.toArr(r => r) ].map(r => r.uid[0] === '!' ? C.skip : this.followRec(r));
        return Drop(null, () => drops.forEach(d => d.dry()));
      },
      modifyRec: function(rec, newVal) {
        
        // A command from Below has wound us up here. Make sure that the
        // Below has permission to modify this `rec` as it desires, and
        // if so do the modification.
        
        if (rec.val !== null && newVal.val !== null)
          if (U.inspOf(rec.val) !== U.inspOf(newVal))
            throw Error(`Can't modify - tried to modify ${U.nameOf(rec.val)} -> ${U.nameOf(newVal)}`);
        
        let fol = this.fols.get(rec);
        if (!fol) throw Error(`Modification denied`);
        
        // Allow if any "modifyAllow" passes and no "modifyBlock" fails
        let anyAllow = false;
        for (let f of fol.modifyAllow.keys()) if (f(newVal)) { anyAllow = true; break; }
        if (!anyAllow) throw Error(`Can't modify since no "any" passed`);
        
        let allPass = true;
        for (let f of fol.modifyBlock.keys()) if (f(newVal)) { allPass = false; break; }
        if (!allPass) throw Error(`Can't modify since an "all" denied`);
        
        if (U.isType(newVal, Object)) rec.drip({ ...(rec.val || {}), ...newVal });
        else                          rec.drip(newVal);
      },
      
      onceDry: function() {
        insp.Rec.onceDry.call(this);
        clearTimeout(this.expiryTimeout); this.expiryTimeout = null;
      },
      /// =ABOVE}
      
      tell: function(msg, conn=null) {
        let conns = this.cpu.connNozz.set;
        if (conns.isEmpty()) throw Error(`Hut ${this.getTerm()} has no Conns`);
        if (conn && !conns.has(conn)) throw Error(`Provided Conn doesn't apply to Hut`);
        
        if (!conn) {
          let bestCost = U.int32;
          for (let conn0 of conns) {
            let cost = conn0.server.cost;
            if (cost < bestCost) { conn = conn0; bestCost = cost; }
          }
        }
        
        conn.tell(msg);
      }
    })});
    
    return { Lands, Hut };
    
  }
});
