/*
TODO: Need some way of marking QElems as "sensitive" so that they cannot be
transmitted over the wire to any recipient. Perhaps an anonymous function in a parent
element that gets to return true or false for every child in that parent's
jurisdiction? It needs to be an anonymous function to allow for any use-case-specific
permissions to be applied.

TODO: When querying for server-side elems, need to be able to add the queried elem to
the tree on the client-side. The current issue is that when the element's parent is
missing (because the address provided for the element had multiple components, and at
least one of the elements in the component-chain was missing client-side), the
element cannot be attached to the tree because no intermediate elements will be
loaded. Approach this by first writing a method to load all intermediate components
and attach them in order. Then the child can be attached.

TODO: Long polling

TODO: Link QGen with PACK.e.ListUpdater, and write corresponding *Updaters for the
other subclasses of QElem. Once this is done any server-side element should be easily
syncable with the client side. With long-polling, it should be beautiful

TODO: Abstract tree class in separate package!!!

TODO: Rename from "quickDev" to "dossier". That's smooth. Remove "QD" prefixes.
*/
var package = new PACK.pack.Package({ name: 'quickDev',
	dependencies: [ 'queries', 'e', 'p' ],
	buildFunc: function() {
		
		var ret = {};
		
		// Add classes
		ret.update({
			
			NAME_REGEX: /^[a-zA-Z0-9-_]+$/,
			NEXT_TEMP: 0,
			getTempName: function() {
				var id = U.id(PACK.quickDev.NEXT_TEMP++);
				
				if (id === 'ffffffff') throw new Error('EXHAUSTED IDS');
				
				return 'TEMP((' + id + '))';
			},
			
			/* Outline - define what a Dossier structure looks like */
			Outline: U.makeClass({ name: 'Outline',
				propertyNames: [ 'c', 'p', 'i' ],
				methods: function(sc) { return {
					
					init: function(params /* c, p, i */) {
						// NOTE: The only Outlines that don't have names are the
						// Outlines for DossierLists
						var c = U.param(params, 'c');
						var p = U.param(params, 'p', {});
						var i = U.param(params, 'i', {});
						
						if (!('name' in p)) p.name = null;
						
						this.c = U.isObj(c, String) ? c : c.title; // If not a string, it's a class
						this.p = p;
						this.i = {};
						
						for (var k in i) {
							var outline = i[k];
							
							if (!U.isInstance(outline, PACK.quickDev.Outline))
								outline = new PACK.quickDev.Outline(outline);
							
							this.i[outline.getProperty('name')] = outline;
						}
					},
					getProperty: function(name, def) {
						if (name in this.p) return this.p[name];
						if (!U.exists(def)) throw new Error('Couldn\'t get property "' + name + '"');
						return def;
					}
					
				};}
			}),
			
			/* Edit - make changes to Dossier structures */
			Editor: U.makeClass({ name: 'Editor',
				methods: function(sc, c) { return {
				
					init: function(params /* add, rem */) {
						this.curReqs = [];
						this.rollBacks = [];
					},
					
					$create: function(outline, data) {
						return this.$add(null, outline, null, data);
					},
					$add: function(par, outline, name, data) {
						/*
						Returns an object with 2 keys:
						1) "$doss"
							A promise that resolves to the doss generated by this method
						2) "reqs"
							An array of requirements, each of which must be resolved
							before $doss resolves
						*/
						
						// Step 1: Initialize the doss
						var reqs = this.curReqs;
						var cls = U.deepGet({ root: C, name: outline.c });
						var doss = new cls({ outline: outline }.update(outline.p));
						
						var promises = [];
						
						// Step 2: Add the name; either directly or with requirements
						if (name) {
							
							doss.updateName(name);
							
						} else {
							
							if (outline.p.name) {
								
								promises.push(new PACK.p.P({ custom: function(resolve, reject) {
									
									reqs.push({
										reqFunc: c.reqNameSimple,
										reqParams: [ doss, outline.p.name ],
										resolve: resolve,
										reject: reject
									});
									
								}}));
								
							} else {
								
								promises.push(new PACK.p.P({ custom: function(resolve, reject) {
									
									reqs.push({
										reqFunc: c.reqNameCalculated,
										reqParams: [ doss ],
										resolve: resolve,
										reject: reject
									});
								
								}}));
								
							}
							
						}
						
						// Step 3: Add the data; either directly or with requirements
						if (data) {
							
							promises.push(doss.$loadFromRawData(data, this));
							
						} else {
							
							// TODO: Is it even possible to get here...? Maybe if `name` is provided but `data` isn't?
							throw new Error('reqData not implemented yet!!!');
							
							// Here's the recursive case through requirements
							promises.push(new PACK.p.P({ custom: function(resolve, reject) {
									
								reqs.push({
									reqFunc: c.reqData,
									reqParams: [ doss ],
									resolve: resolve,
									reject: reject
								});
								
							}}));
							
						}
						
						// Step 4: Attach to parent
						if (par) par.addChild(doss); // TODO: Mystery why this can't happen right in the beginning of `$add`???
						
						return new PACK.p.P({ all: promises }).then(function() { return doss; });
					},
					
					resolveReqs: function() {
						var reqs = this.curReqs;
						this.curReqs = []; // Resolving reqs resets all requirements no matter what
						
						if (this.tryResolveReqs(reqs)) {
							reqs.forEach(function(r) { r.resolve(); });
						} else {
							var err = new Error('Couldn\'t resolve requirements');
							reqs.forEach(function(r) { r.reject(err); });
							this.rollBackChanges();
						}
					},
					tryResolveReqs: function(unresolved) {
						// TODO: Need to consider reqs being added DURING resolveReqs
						// NOTE: `this.curReqs` is EMPTY when this method is called from `resolveReqs`
						var resolved = [];
						
						while (unresolved.length) {
							var solvedOne = false;
							var noProgress = [];
							
							for (var i = 0, len = unresolved.length; i < len; i++) {
								
								var reqDat = unresolved[i];
								
								var result = reqDat.reqFunc.apply(null, reqDat.reqParams);
								
								if (result) {
									solvedOne = true;
									resolved.push(reqDat);
								} else {
									noProgress.push(reqDat);
								}
								
							}
							
							if (!solvedOne) {
								console.log('Couldn\'t solve reqs', unresolved[0].reqFunc, unresolved[0].reqParams);
								return false;
							}
							
							unresolved = noProgress;
							
						}
						
						return true;
					},
					rollBackChanges: function() {
						throw new Error('not implemented ur data is corrupt haha');
					}
				
				};},
				statik: {
					reqNameSimple: function(doss, name) {
						try {
							
							doss.updateName(name);
							return true;
							
						} catch(err) { console.log('REQSIMP ERR:', err.message); return false; }
					},
					reqNameCalculated: function(doss) {
						try {
							
							var name = doss.par.getChildName(doss);
							doss.updateName(name);
							return true;
							
						} catch (err) { console.log('REQCALC ERR:', err.message); return false; }
					},
					reqData: function(doss) {
						try {
							
							// TODO: Add a value and children to `doss` as appropriate
							
						} catch (err) { console.log('REQDATA ERR:', err.message); return false; }
					},
					
					rollBackAdd: function(doss) {
						try {
							
							if (!doss.par) throw new Error('Can\'t un-add doss without parent');
							doss.par.remChild(doss);
							return true;
							
						} catch (err) { console.log('ROLLBACK ERR:', err.message); return false; }
					},
					rollBackRem: function(par, doss, originalName) {
						try {
							
							par.addChild(doss);
							var fatal = par.children[originalName] !== doss
								? new Error('FATAL ROLLBACK REM: added child back, but name changed :(')
								: null;
							
							if (!fatal) return true;
							
						} catch (err) { console.log('ROLLBACK REM:', err.message); return false; }
						
						throw fatal;
					}
				}
			}),
				
			/* Dossier */
			Dossier: U.makeClass({ name: 'Dossier',
				superclassName: 'QueryHandler',
				methods: function(sc) { return {
					
					init: function(params /* outline */) {
						sc.init.call(this, params);
						
						this.name = PACK.quickDev.getTempName();
						this.outline = U.param(params, 'outline');
						
						this.par = null;
					},
					
					// Name
					hasResolvedName: function() {
						return this.name.substr(0, 5) !== 'TEMP(';
					},
					updateName: function(name) {
						if (!PACK.quickDev.NAME_REGEX.test(name)) throw new Error('Illegal Dossier name: "' + name + '"');
						
						var par = this.par;
						
						if (par) par.remChild(this);
						this.name = name.toString();
						if (par) par.addChild(this);
					},
					
					// Heirarchy
					getAncestry: function() {
						var ret = [];
						var ptr = this;
						while(ptr !== null) {
							ret.push(ptr);
							ptr = ptr.par;
						}
						return ret;
					},
					getNameChain: function() {
						return this.getAncestry().reverse().map(function(doss) {
							return doss.name.toString();
						});
					},
					getAddress: function() {
						return this.getNameChain().join('.');
					},
					getRoot: function() {
						var ptr = this;
						while (ptr.par) ptr = ptr.par;
						return ptr;
					},
					getChild: function(address) {
						// Safe to disregard "use" here, because QSet's "use" returns "this"
						// TODO: is it safe to assume this will never be overloaded?
						if (address.length === 0) return this; // Works for both strings and arrays
						
						if (address.constructor !== Array) address = address.toString().split('.');
						
						var ptr = this;
						for (var i = 0, len = address.length; (i < len) && (ptr !== null); i++)	{
							var a = address[i];
							if (a[0] === '@') {
								ptr = ptr.getNamedChild(a.substr(1));
								if (ptr) ptr = ptr.dereference();
							} else {
								ptr = ptr.getNamedChild(a);
							}
						}
						
						return ptr;
					},
					getNamedChild: function(name) {
						if (name === '')				return this;
						if (name === '~par')		return this.par;
						if (name === '~root')	return this.getRoot();
						
						return null;
						// throw new Error('Invalid child name: "' + name + '"');
					},
					
					// Server/client
					$doRequest: function(params /* command, params, serialize */) {
						
						if (U.isObj(params, String)) params = { command: params };
						
						return PACK.queries.$doQuery({
							address:		this.getAddress(),
							command:		U.param(params, 'command'),
							params:			U.param(params, 'params', {}),
							serialize:	U.param(params, 'serialize', [])
						});
					},
					$handleQuery: function(params) {
						var command = U.param(params, 'command');
						
						if (command === 'getRawData') {
							
							return PACK.p.$p(this.getRawDataView());
							
						} else if (command === 'getData') {
							
							return PACK.p.$p(this.getDataView({}));
							
						}
						
						throw new Error('Couldn\'t handle invalid command: "' + command + '"');
					},
					
					$loadFromRawData: function(data, editor) {
						throw new Error('not implemented');
					},
					
					dereference: function() {
						throw new Error('Cannot dereference "' + this.constructor.title + '"');
					},
					
					getRawDataView: function() {
						throw new Error('Not implemented');
					},
					getDataView: function(existing) {
						if (!existing) throw new Error('Called `getDataView` without `existing` set');
						
						var addr = this.getAddress();
						if (addr in existing) return existing[addr];
						
						var ret = this.getDataView0(existing);
						existing[addr] = ret;
						
						return ret;
					},
					getDataView0: function(existing) {
						throw new Error('not implemented');
					}
					
				};}
			}),
			DossierSet: U.makeClass({ name: 'DossierSet',
				superclassName: 'Dossier',
				methods: function(sc) { return {
					init: function(params /* outline */) {
						sc.init.call(this, params);
						this.children = {};
						this.length = 0;
					},
					
					// Child methods
					addChild: function(child) {
						if (child.par && child.par !== this) throw new Error('Tried to add: "' + child.getAddress() + '"');
						if (child.name in this.children) throw new Error('Tried to overwrite: "' + this.children[child.name].getAddress() + '"');
						
						child.par = this;
						this.length++;
						this.children[child.name] = child;
						
						return child;
					},
					remChild: function(child) {
						// If `child` was supplied as a number or a string, resolve it
						if (!U.isInstance(child, PACK.quickDev.Dossier)) child = this.children[child];
						
						if (!child || !(child.name in this.children)) throw new Error('Couldn\'t remove child "' + child.getAddress() + '"');
						
						delete this.children[child.name];
						this.length--;
						child.par = null;
						
						return child;
					},
					getNamedChild: function(name) {
						if (name in this.children) return this.children[name];
						return sc.getNamedChild.call(this, name);
					},
					getChildName: function(child) {
						// Calculates the name that should be used to label the child
						throw new Error('Not implemented');
					},
					getChildOutline: function(name) {
						// Returns the outline needed by a child named "name"
						throw new Error('Not implemented');
					},
					
					$loadFromRawData: function(data, editor) {
						// Loaded once all children have been loaded via the editor
						var promiseSet = [];
						for (var k in data) promiseSet.push(editor.$add(this, this.getChildOutline(k), k, data[k]));
						
						return new PACK.p.P({ all: promiseSet });
					},
					
					getRawDataView: function() {
						var ret = {};
						for (var k in this.children) ret[k] = this.children[k].getRawDataView();
						return ret;
					},
					getDataView0: function(existing) {
						var ret = {};
						for (var k in this.children) ret[k] = this.children[k].getDataView(existing);
						return ret;
					}
				};}
			}),
			DossierDict: U.makeClass({ name: 'DossierDict',
				superclassName: 'DossierSet',
				methods: function(sc) { return {
					init: function(params /* outline */) {
						sc.init.call(this, params);
					},
					
					// Child methods
					getChildName: function(child) {
						throw new Error(this.constructor.title + ' doesn\'t support `getChildName`');
					},
					getChildOutline: function(name) {
						if (!name) throw new Error('DossierDict needs `name` for `getChildOutline`');
						if (name in this.outline.i) return this.outline.i[name];
						return null;
					}
				};}
			}),
			DossierList: U.makeClass({ name: 'DossierList',
				superclassName: 'DossierSet',
				methods: function(sc) { return {
					init: function(params /* outline, innerOutline, prop */) {
						sc.init.call(this, params);
						
						this.innerOutline = U.param(params, 'innerOutline');
						this.prop = U.param(params, 'prop', '~par/nextInd');
						
						// `this.nextInd` keeps track of the lowest unused index
						// that a child is named in `this.children`. It is only
						// updated when children with numeric names are added.
						// Useful as the "propName" when using address-props
						// ("the.address.path/propName")
						this.nextInd = 0;
						
						// Convert outline params to Outline
						if (U.isObj(this.innerOutline, Object)) this.innerOutline = new PACK.quickDev.Outline(this.innerOutline);
					},
					
					// Child methods
					addChild: function(child) {
						child = sc.addChild.call(this, child);
						while (this.nextInd in this.children) this.nextInd++;
					},
					remChild: function(child) {
						child = sc.remChild.call(this, child); // sc.remChild alters the parameter being dealt with
						
						// Two different possibilities here:
						// 1) Fill holes whenever possible adding
						// 2) Always cascade to fill holes
						// Implementing #1
						if (!isNaN(child.name)) this.nextInd = parseInt(child.name, 10);
						
						return child;
					},
					getChildName: function(doss) {
						var pcs = this.prop.split('/');
						var addr = pcs[0];
						var prop = pcs[1];
						
						var child = doss.getChild(addr);
						if (!child) throw new Error('Couldn\'t get prop child: (' + doss.getAddress() + ').getChild("' + addr + '")');
						if (!(prop in child)) throw new Error('Child "' + child.getAddress() + '" missing prop "' + prop + '"');
						
						return child[prop];
					},
					getChildOutline: function(name) {
						// All DossierList children have the same outline
						return this.innerOutline;
					}
					
				};}
			}),
			
			/* DossierValue */
			DossierValue: U.makeClass({ name: 'DossierValue',
				superclassName: 'Dossier',
				methods: function(sc) { return {
					init: function(params /* outline */) {
						sc.init.call(this, params);
						this.value = null;
					},
					
					$loadFromRawData: function(data, editor) {
						this.setValue(data);
						return PACK.p.$null;
					},
					
					setValue: function(value) {
						this.value = value;
					},
					
					getRawDataView: function() {
						return this.value;
					},
					getDataView0: function(existing) {
						return this.value;
					}
					
				};}
			}),
			DossierString: U.makeClass({ name: 'DossierString',
				superclassName: 'DossierValue',
				methods: function(sc) { return {
					init: function(params /* outline */) {
						sc.init.call(this, params);
					}
				}; }
			}),
			DossierInt: U.makeClass({ name: 'DossierInt',
				superclassName: 'DossierValue',
				methods: function(sc) { return {
					init: function(params /* outline */) {
						sc.init.call(this, params);
					}
				}; }
			}),
			DossierRef: U.makeClass({ name: 'DossierRef',
				superclassName: 'DossierString',
				methods: function(sc) { return {
					init: function(params /* outline */) {
						sc.init.call(this, params);
					},
					getRefAddress: function() {
						return this.outline.getProperty('baseAddress', '~root') + '.' + this.value;
					},
					dereference: function() {
						return this.getChild(this.getRefAddress());
					},
					getRawDataView: function() {
						return 'GET: ' + this.getRefAddress();
					},
					getDataView0: function(existing) {
						return this.dereference().getDataView(existing);
					}
				}; }
			}),
			
			/* Folder - Folders contain Dossiers */
			Folder: U.makeClass({ name: 'Folder',
				methods: function(sc, c) { return {
					init: function(params /* */) {
						this.$dossier = this.$getDossier();
					},
					$getDossier: function() {
						throw new Error('not implemented');
					}
				};}
			}),
			SimpleFolder: U.makeClass({ name: 'SimpleFolder',
				methods: function(sc, c) { return {
					init: function(params /* dossier */) {
						this.dossier = U.param(params, 'dossier');
					},
					$getDossier: function() {
						return PACK.p.$p(this.dossier);
					}
				};}
			}),
			AddressFolder: U.makeClass({ name: 'AddressedFolder',
				methods: function(sc, c) { return {
					init: function(params /* $root, address */) {
						// Root can be either a promise or a String
						this.$root = U.$param(params, '$root', null);
						this.address = U.param(params, 'address');
						sc.init.call(this);
					},
					$getDossier: function() {
						return new PACK.p.P({ args: [ this.$root, this.address ] })
							.then(function(root, addr) {
								return root.getChild(addr);
							})
					}
				};}
			}),
			
			
			/* Versioner - maintain evolving Dossier structures */
			Versioner: U.makeClass({ name: 'Versioner',
				methods: function(sc) { return {
					init: function(params /* versions */) {
						this.versions = U.param(params, 'versions');
					},
					addVersion: function(params /* name, detect, $apply */) {
						this.versions.push({
							name: 	U.param(params, 'name'),
							detect: U.param(params, 'detect'),
							$apply: U.param(params, '$apply')
						});
					},
					$getDoss: function() {
						
						var $dossData = new PACK.p.P({ val: { versionName: 'empty-state', doss: null } });
						
						this.versions.forEach(function(ver) {
							
							$dossData = $dossData.then((function(ver, dossData) {
								
								var versionName = dossData.versionName;
								var doss = dossData.doss;
								
								if (ver.detect(doss)) {
									
									console.log('Transitioning from version "' + versionName + '" to "' + ver.name + '"...');
									return ver.$apply(doss).then(function(doss) {
										console.log('Success!');
										return { versionName: ver.name, doss: doss };
									});
									
								} else {
									
									console.log('Skipping version "' + ver.name + '".');
									return dossData;
									
								}
								
							}).bind(null, ver));
							
						});
						
						return $dossData.then(function(dossData) { return dossData.doss });
						
					}
				};}
			}),
			
		});
		
		/*1278*/
		
		return ret;
	}
});
package.build();
